import { createSelector, createEntityAdapter } from "@reduxjs/toolkit";
import { apiSlice } from "../../app/api/apiSlice";

// NORMALIZATION of states -> recommended in docs, no duplication of data, creates an ID lookup
// Normalized state shape contains a single "entities" object which contains all of the entities in the store, indexed by ID, and a "ids" array which contains a list of those IDs, in the order they were inserted into the store
// Entities cannot be iterated over, but the ids array can, so we'll use the ids array to get data from entities when we need them
// createEntityAdapter is a function that generates a set of prebuilt reducers and selectors for performing CRUD operations on a normalized state structure containing instances of a particular type of data object. These reducer functions may be passed as case reducers to createReducer and createSlice. They may also be used as "mutating" helper functions inside of createReducer and createSlice.
// createEntityAdapter API's benefits: abstracts more logic from components, has built-in CRUD methods, automatic selector generation -> make our slices less complicated and easier to manage
const usersAdapter = createEntityAdapter({});

// Get the default initial state generated by the createEntityAdapter
const initialState = usersAdapter.getInitialState();

export const usersApiSlice = apiSlice.injectEndpoints({
  // Methods to interact with the API
  endpoints: builder => ({
    getUsers: builder.query({
      // query method
      query: () => ({
        url: "/users",
        // Make sure that the result is not an error and the response status code is 200
        validateStatus: (response, result) => {
          return response.status === 200 && !result.isError;
        },
      }),
      // keepUnusedDataFor: 60, // keep the data in the cache for 60 seconds -> default value is 60 -> optional
      // Similar to axios, we can transform the response data before it gets stored in the cache
      // This is very important when we work with MongoDB in our Backend
      transformResponse: responseData => {
        // Create a new array of users with the id field added
        const loadedUsers = responseData.map(user => {
          // Must do this for the ids array of createEntityAdapter to work because the id field is not named "id" in MongoDB
          user.id = user._id;
          return user;
        });
        // When using RTK Query with createEntityAdapter, we need to normalize our states, so here we're sending the new state the the usersAdapter
        return usersAdapter.setAll(initialState, loadedUsers);
      },
      // Provide the tags so that we can invalidate the cache when we make changes to the data using mutations
      providesTags: (result, error, arg) => {
        if (result?.ids) {
          // If we have a list of users, we want to invalidate the cache for each user in the list -> so if any of the user data in the list gets invalidated, the whole list will be fetched again to display the new data
          // We may possibly get a result without any ids (when an error has occurred) -> account for that with the 'else' here
          return [
            { type: "User", id: "LIST" },
            ...result.ids.map(id => ({ type: "User", id })),
          ];
        } else return [{ type: "User", id: "LIST" }];
      },
    }),
    // mutation methods (POST, PATCH, DELETE) to make changes to the data
    addNewUser: builder.mutation({
      query: initialUserData => ({
        url: "/users",
        // have method here because there can be POST, PATCH, or DELETE methods
        method: "POST",
        body: {
          ...initialUserData,
        },
      }),
      // The results get cached by default, so we need to invalidate the previous cache so that it will update and show the new changes. If we don't do this, it will not update and we'll only see the cached version of the data, not the new changes
      // assign a tag to the mutation so that we can invalidate the cache -> it will know which mutation invalidates the cache -> it'll automatically refetch that data for us, and the page will be rerendered to show the new changes
      invalidatesTags: [{ type: "User", id: "LIST" }], // the user list will be invalidated -> will be updated
    }),
    updateUser: builder.mutation({
      query: initialUserData => ({
        url: "/users",
        // PUT replaces the entire object, PATCH only replaces the fields that are passed in
        method: "PATCH",
        body: {
          ...initialUserData,
        },
      }),
      // invalidate the cache for the user that was updated -> specifying the id of the user
      invalidatesTags: (result, error, arg) => [{ type: "User", id: arg.id }],
    }),
    deleteUser: builder.mutation({
      query: ({ id }) => ({
        url: `/users`,
        method: "DELETE",
        body: { id },
      }),
      invalidatesTags: (result, error, arg) => [{ type: "User", id: arg.id }],
    }),
  }),
});

// RTK Query automatically creates custom hooks based on the endpoints we defined above
// Export the custom hooks
export const {
  useGetUsersQuery,
  useAddNewUserMutation,
  useUpdateUserMutation,
  useDeleteUserMutation,
} = usersApiSlice;

// returns the query result object
export const selectUsersResult = usersApiSlice.endpoints.getUsers.select();

// Since the query result object doesn't only contain data, we need to create memoized selector
const selectUsersData = createSelector(
  // Input function: selectUsersResult, which returns the query result object
  selectUsersResult,
  // Output function: usersResult => usersResult.data, which returns the data from the query result object
  usersResult => usersResult.data // normalized state object with ids & entities
);

// The getSelectors method of createEntityAdapter creates these selectors automatically and we then rename them with aliases using destructuring
// These are memoized selectors that will be useful when we want to optimize our app
export const {
  selectAll: selectAllUsers,
  selectById: selectUserById,
  selectIds: selectUserIds,
  // We have to pass a selector into getSelectors that returns the users slice of state
} = usersAdapter.getSelectors(state => selectUsersData(state) ?? initialState);
// selectUsersData(state) -> returns the data from the query result object -> return the normalized state
// ?? initialState -> if selectUsersData(state) is null or undefined (usually in the first time the app loads), then use initialState -> nullish coalescence (if the left side of ?? is null, then return the right side)
// selectAllUsers -> returns an array of all the users
// selectUserById -> returns a single user object
// selectUserIds -> returns an array of all the user ids
